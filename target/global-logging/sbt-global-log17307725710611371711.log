[0m[[0m[0mdebug[0m] [0m[0m> Exec(collectAnalyses, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Processing event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: initialized: JsonRpcNotificationMessage(2.0, initialized, {})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///home/amir/my-work/Scala-Chisel-Learning-Journey/src/main/scala/riscv/fivestage.scala","languageId":"scala","version":1,"text":"package riscv\nimport chisel3._\nimport chisel3.util._\n\nclass fivestage extends Module{\n    val io = IO(new Bundle{\n        val out = Output(UInt(32.W))\n    })\n    val fu = Module(new forwarding)\n    dontTouch(fu.io)\n    val pcounter = Module(new pc)\n    dontTouch(pcounter.io)\n    val im = Module(new instMem(\"/home/amir/V\"))\n    dontTouch(im.io)\n    val reg = Module(new register)\n    dontTouch(reg.io)\n    val cu = Module (new control)\n    dontTouch(cu.io)\n    val alu = Module(new ALU)\n    dontTouch(alu.io)\n    val ac = Module(new alu_control)\n    dontTouch(ac.io)\n    val imem = Module(new imdgen)\n    dontTouch(imem.io)\n    val m= Module(new memory)\n    dontTouch(m.io)\n    val b= Module(new Branch)\n    dontTouch(b.io)\n    val p1 = Module(new pipeline1)\n    dontTouch(p1.io)\n    val p2 = Module(new pipeline2)\n    dontTouch(p2.io)\n    val p3 = Module(new pipeline3)\n    dontTouch(p3.io)\n    val p4 = Module(new pipeline4)\n    dontTouch(p4.io)\n    io.out := 1.U\n    b.io.Aluop := 0.U\n    ac.io.op_code := 0.U\n    pcounter.io.in := 0.U\n    reg.io.wen := 0.B\n    p2.io.rs1_add_in := 0.U\n    imem.io.pc := 0.U\n    p2.io.rs1 := 0.S\n    p2.io.imme_in := 0.U\n    b.io.in_a := 0.S\n    p3.io.rs2add :=0.U\n    p4.io.memrd:=0.U\n    p2.io.rs2 := 0.S\n    p2.io.IF_pc :=0.U\n    p2.io.rs2_add_in :=0.U\n    p1.io.pc4_in :=0.U\n    b.io.in_b :=0.S\n\n    \n    //\n    fu.io.p1_rs1 := p2.io.rs1_add_out\n    fu.io.p1_rs2 := p2.io.rs2_add_out\n    fu.io.p2_rd := p3.io.rdadd_out\n    fu.io.p2_regWrite := p3.io.regwr\n    fu.io.p3_rd := p4.io.rdadd_out\n    fu.io.p3_regwrite :=p4.io.regwr_out \n    //\n\n\n\n    im.io.addr := pcounter.io.out1\n    p1.io.pc_in := pcounter.io.out1\n    p1.io.inst_in := im.io.instr\n    //-------------------------------\n    cu.io.op_code := p1.io.inst_out(6,0)\n    reg.io.rs1 := p1.io.inst_out(19,15)\n    dontTouch(reg.io.rs1)\n    reg.io.rs2 := p1.io.inst_out(24,20)\n    dontTouch(reg.io.rs2)\n    imem.io.instr := p1.io.inst_out\n    p2.io.func3_in := p1.io.inst_out(14,12) \n    p2.io.func7_in := p1.io.inst_out(30)\n    p2.io.rd_add_in := p1.io.inst_out(11,7)\n    p2.io.IF_pc := p1.io.pc_in \n    p2.io.rs1 := reg.io.read1 \n    p2.io.rs2 := reg.io.read2  \n    p2.io.imme_in := imem.io.imtype\n   \n    //\n    //wb1\n    p2.io.ctrl_regwr_in := cu.io.regwrite\n    p2.io.ctrl_memtoreg_in := cu.io.memtoreg\n    //M1\n    p2.io.ctrl_branch_in :=  cu.io.branch\n    p2.io.ctrl_memwr_in :=    cu.io.memwrite\n    p2.io.ctrl_memrd_in :=   cu.io.memread\n    //EX1\n    p2.io.ctrl_Aluop_in := cu.io.aluop\n    p2.io.ctrl_Alu_src :=  cu.io.op_b_sel\n    //wb2\n    p3.io.memtoreg:= p2.io.ctrl_memtoreg_out\n    p3.io.regwr   := p2.io.ctrl_regwr_out\n    //M2\n    p3.io.branch := p2.io.ctrl_branch_out\n    p3.io.memwr := p2.io.ctrl_memwr_out\n    p3.io.memrd := p2.io.ctrl_memrd_out\n    //\n    \n    \n    \n    \n    p3.io.p2_pc := (p2.io.IF_pc_out).asUInt + p2.io.imme_out\n    val mux1 = Mux(p2.io.op_Alu_src_out,p2.io.imme_out,(p2.io.rs2_out).asUInt)\n    //alu.io.in_a := p2.io.rs1_out\n    //alu.io.in_b := (mux1).asSInt \n    p3.io.alu_output := alu.io.Result\n    //p3.io.rs2 := p2.io.rs2_out\n    ac.io.func3 :=  p2.io.func3_out\n    ac.io.func7 :=  p2.io.func7_out \n    ac.io.Aluop := p2.io.ctrl_Aluop_out\n    alu.io.Aluop := ac.io.ctrl\n    p3.io.rdadd := p2.io.rd_add_out\n    p3.io.branch := 0.B\n    //stage3 cmplt\n    //WB\n    p4.io.memtoreg := p3.io.memtoreg_out\n    p4.io.regwr := p3.io.regwr_out\n    \n    val and = p3.io.branch_out && 0.B\n    m.io.addr := (p3.io.alu_output_out).asUInt\n    m.io.dataIn := (p3.io.rs2_out).asUInt\n    m.io.write := p3.io.memwr_out\n    m.io.red :=   p3.io.memrd_out\n    p4.io.data_mem := m.io.dataOut\n    p4.io.alu_output:=p3.io.alu_output_out\n    p4.io.rdadd := p3.io.rdadd_out\n    reg.io.wen := p4.io.regwr_out\n    val mux2 = Mux(p4.io.memtoreg_out,(p4.io.data_mem_out).asSInt,p4.io.alu_output_out)\n    reg.io.write_data  := mux2\n    reg.io.rd := p4.io.rdadd_out\n    pcounter.io.in := Mux(and,p3.io.p2_pc_out,pcounter.io.out2)\n    /// --forwarding version\n    p2.io.rs1_add_in := p1.io.inst_out(19,15)\n    p2.io.rs2_add_in := p1.io.inst_out(24,20)\n    p2.io.rd_add_in  := p1.io.inst_out(11,7)\n\n    \n\n    alu.io.in_a := MuxLookup(fu.io.f_a,0.S, Array(\n        (0.U) ->  (p2.io.rs1_out).asSInt,\n        (1.U) ->  (mux2).asSInt  ,\n        (2.U) ->  (p3.io.alu_output_out).asSInt\n        \n    ))\n    val muxx = MuxLookup(fu.io.f_b,0.S , Array(\n        (0.U) -> (mux1).asSInt  ,\n        (1.U) -> (mux2).asSInt,\n        (2.U) -> (p3.io.alu_output_out).asSInt\n        \n    ))\n\n    alu.io.in_b := muxx\n    p3.io.rs2 := muxx\n    reg.io.p4_rd := p4.io.rdadd_out\n    reg.io.p3_rd:= p3.io.alu_output_out\n    //reg.io.p3_rd := p3.io.rdadd_out \n    //reg.io.p3_alu := p3.io.alu_output_out      \n\n\n\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / collectAnalyses[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: Signal, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0manalysis location (/home/amir/my-work/Scala-Chisel-Learning-Journey/target/scala-2.12/zinc/inc_compile_2.12.zip,true)[0m
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 1 s, completed Mar 9, 2023, 1:55:12 PM[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Done event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m
